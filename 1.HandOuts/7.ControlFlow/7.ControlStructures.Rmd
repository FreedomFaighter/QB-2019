---
title: '7\. Control Structures'
author: 'Z620: Quantitative Biodiversity, Indiana University'
header-includes:
   - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
---

## OVERVIEW

In Dante's satire of hell each layer contains a new iterative task for the tortured to endure for eternity. Much of the power of computing stems from the efficiency of computers in performing small tasks in an iterative manner. This lesson introducts the concepts of control structures and random numbers. We will use these tools to understand the diversity of jellybeans flavors, but these basic tools are useful for a numbers of tasks in computing and will help you automate many of your future work flows.

## 1) INTRODUCTION TO CONTROL STRUCTURES
Control structures allow you to control the flow of execution of a script. Today, we will focus on the "for loop", but other common control structures include: 
"if, else"
"while"
and "next"

A quick tutorial of common control structures in R can be found at https://ramnathv.github.io/pycon2014-r/learn/controls.html



```{r, results = 'hide'}
rm(list = ls()) # clear working directory
```

### A. 'If' and 'Else' Logical Tests

Short intro: when and why to use
1. The general syntax for an "if, else" control stucture in the R language.
   if (condition) {
   	# do something
   } else {
   	# do something else
   }
2. An example of the an "if, else" control stucture.  

```{r}
x <- 1:15
if (sample(x, 1) <= 10) {
   print("x is less than 10")
} else {
   print("x is greater than 10")
}
```
3. "if" accepts logical values; can accept numbers but not strings.
4. "if" can be complemented by an "else"
5. ifelse as shorthand
6. if-else can be strung to create hirearchy of tests

### B. For Loops

Let's introduce the "for loop" as a control structure.

**Syntax**
The specific syntax of for loops will look different in other language but basics syntax remains the same.
1. Start a loop with for
2. Declare variable and number of iteration
3. Tasks to perform in code block

                       1.     2.         3.
In R this looks like: for(i in 1:10){ print(i) }

```{r}
for(i in 1:10){
  print(i)
}
```

In this sturcture i is a variable that will hold each interger from 1 to 10 during each successive pass through the loop.

You can use this structure to move through each item of vector and perfrom any number of tasks to each element.

Like printing out a list of fruits.
```{r}
x <- c("apples", "oranges", "bananas", "strawberries")

for (i in seq(x)) {
    print(x[i])
}
```
**Note that a for loop can iterate over any type of vector: logical, numerical, string. You can also iterate over vectors using indices (R counts from 1 and not form 0 like some other languages)**

Or get the number of characters in each item of the same list.

```{r}
for (i in seq(x)) {
  len <- nchar(x[i])
  print(len)
}
```
**Note on the use of for loops**
When possible try to avoid them. They take a long time to execute and are somewhat clumsy. Consider using apply type functions.

The sapply function can be used to get the same results as the loop above.

```{r}
sapply(x, nchar)
```

### Combining for and if
e.g. print only numbers that can be divided by 3

```{r}
for(i in 1:10){
  if(i %% 3 == 0){
    print(i)
  }
}
```

### While loops
Another loop control structure is the "while loop".

An example of the while loop.

```{r}
i <- 1
while (i < 10) {
    print(i)
    i <- i + 1
}
```
Notice that a while loop needs an specific break point.

What would happen if the code block was changed to subtract 1 from i in each iteration of the loop?

### 2) REVISITNG JELLY BEAN WITH CONTROL STRUCTURE

### A. Generate a Source Community by Drawing from Lognormal Distribution
```{r}
set.seed(6)
digital.jelly <- round(rlnorm(n = 20, meanlog = 5 ))
digital.jelly <- sort(digital.jelly,decreasing = T)
names(digital.jelly) <- paste0("species.",LETTERS[seq(digital.jelly)])
plot(digital.jelly, log='y')
```

Explain the details of commands above

### B. Sample the Source Community

Function to generate a single sample
```{r}
sample.community <- function (x,n){
  survey <- sample(seq(x),size = n, replace = T,prob = x)
  survey.sum <- rep(0, length(x))
  for (i in survey){
    survey.sum[i]<-survey.sum[i]+1
  }
  return(survey.sum)
}
```

### C. Calculate Alpha Diversity

```{r}
# Functions from alpha diversity handout
S.obs <- function(x = ""){
  rowSums(x > 0) * 1
}

S.chao1 <- function(x = ""){
  S.obs(x) + (sum(x == 1)^2) / (2 * sum(x == 2))
}
```

### D. Resampling

Repeat sampling and calculations 100 times using for loop. 
Look at estimated prameter distribution along with real value.

**The code below works well as script but not in markdown...*
```{r}
S.true <- length(digital.jelly)
plot(0, t = "n", xlim = c(S.true/2, 1.5 * S.true), ylim = c(S.true/2, 1.5 * S.true), 
     xlab = "S.obs", ylab = "S.chao1")
abline(h = S.true, v = S.true, col = "red")

N <- 100

for ( i in 1:100){
  sample.dj <- sample.community(digital.jelly,N)
  x<-S.obs(t(sample.dj))
  y<-S.chao1(t(sample.dj))
  points(x,y)
}
```

Play around with the sample size (by changing the value of `N`). How does sampe size affect observed and estimated fitness?

### E. Collector's Curve

S.observed as a function of N. First take a single sample of size N from the source population. Subsample you sample with sampe sizes increasing from 1 to N and note the observed richness for each subsample.
```{r}

#first take a single sample of size N from the source population
N<-1000
sample.dj <- sample.community(digital.jelly,n = N)

#generate vector to store results
S.collectors <- rep(NA, N)
#loop through 1:N and check S.obs
for (i in 1:N){
  current <-  sample.community(sample.dj,n = i)
  S.collectors[i] <- S.obs(t(current))
}

plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
```
What is the samllest sampe size to indicate the true richness? 
What is the largest sample size to underestimate richness?
What sample size wiuld you recommend for the next survey of ths community?

5. using for loop generate multiple communities and repeat 2-4 with beta diversity

